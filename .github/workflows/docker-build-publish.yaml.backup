---
# SPDX-License-Identifier: Apache-2.0
# SPDX-FileCopyrightText: 2025 The Linux Foundation

name: 'Docker Build and Publish'

on:
  workflow_dispatch:
  push:
    branches: ['main']
    paths:
      - 'Dockerfile'
      - 'src/**'
      - 'pyproject.toml'
      - 'pdm.lock'
      - 'requirements-docker.txt'
      - '.github/workflows/docker-build-publish.yaml'
  pull_request:
    branches: ['main']
    paths:
      - 'Dockerfile'
      - 'src/**'
      - 'pyproject.toml'
      - 'pdm.lock'
      - 'requirements-docker.txt'
      - '.github/workflows/docker-build-publish.yaml'
  release:
    types: [published]
  # Allow other workflows to trigger this one
  workflow_call:
    outputs:
      image-tag:
        description: 'The built image tag'
        value: ${{ jobs.docker-build.outputs.image-tag }}
      image-digest:
        description: 'The built image digest'
        value: ${{ jobs.docker-push.outputs.image-digest }}

permissions:
  contents: read
  packages: write
  id-token: write
  attestations: write

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  docker-build:
    name: 'Build Docker Image'
    runs-on: ubuntu-latest
    timeout-minutes: 20
    outputs:
      image-digest: ${{ steps.build.outputs.digest }}
      image-tag: ${{ steps.extract-tag.outputs.primary-tag }}
      image-tags: ${{ steps.meta.outputs.tags }}
      image-labels: ${{ steps.meta.outputs.labels }}

    steps:
      # Harden the runner used by this workflow
      - name: Harden Runner
        uses: step-security/harden-runner@0634a2670c59f64b4a01f0f96f84700a4088b9f0 # v2.12.0
        with:
          egress-policy: audit

      - name: Checkout repository
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2

      # Set up Docker Buildx with simplified configuration
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@8026d2bc3645ea78b0d2544766a1225eb5691f89 # v3.8.0

      # Extract metadata for tags and labels
      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@902fa8ec7d6ecbf8d84d538b9b233a880e428804 # v5.7.0
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            # set latest tag for default branch
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=semver,pattern={{major}}
            type=sha
            # set latest tag for main branch
            type=raw,value=latest,enable={{is_default_branch}}
          labels: |
            org.opencontainers.image.title=HTTP API Tool
            org.opencontainers.image.description=A Python HTTP/HTTPS API testing tool for GitHub Actions and CLI usage
            org.opencontainers.image.vendor=The Linux Foundation

      # Extract the primary tag for use in other jobs
      - name: Extract primary tag
        id: extract-tag
        run: |
          echo "primary-tag=$(echo '${{ steps.meta.outputs.tags }}' | head -n1)" >> "$GITHUB_OUTPUT"

      # Build Docker image with resilient caching
      - name: Build Docker image (multi-platform)
        id: build
        continue-on-error: false
        uses: docker/build-push-action@48aba3b46d1b1fec4febb7c5d0c644b249a11355 # v6.10.0
        with:
          context: .
          file: ./Dockerfile
          platforms: linux/amd64,linux/arm64
          push: false  # Build only, don't push yet
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          # Use GitHub Actions cache with proper invalidation for Docker changes
          cache-from: |
            type=gha,scope=multiplatform-build
            type=gha,scope=multiplatform-build-${{ hashFiles('Dockerfile', 'requirements-docker.txt', 'pyproject.toml') }}
          cache-to: |
            type=gha,mode=max,scope=multiplatform-build-${{ hashFiles('Dockerfile', 'requirements-docker.txt', 'pyproject.toml') }}
          # Build arguments for optimization
          build-args: |
            BUILDKIT_INLINE_CACHE=1
          # Store as OCI format for multi-platform support
          outputs: type=oci,dest=/tmp/docker-image-multiplatform.tar

      # Build single-platform image for testing
      - name: Build single-platform image for testing
        uses: docker/build-push-action@48aba3b46d1b1fec4febb7c5d0c644b249a11355 # v6.10.0
        with:
          context: .
          file: ./Dockerfile
          platforms: linux/amd64  # Single platform for local testing
          push: false
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          # Use cache from GHA with proper cache invalidation for Docker changes
          cache-from: |
            type=gha,scope=test-build
            type=gha,scope=test-build-${{ hashFiles('Dockerfile', 'requirements-docker.txt', 'pyproject.toml') }}
          cache-to: |
            type=gha,mode=max,scope=test-build-${{ hashFiles('Dockerfile', 'requirements-docker.txt', 'pyproject.toml') }}
          # Export as Docker tar for testing
          outputs: type=docker,dest=/tmp/docker-image-test.tar

      # Upload built images as artifacts
      - name: Upload multi-platform image artifact
        uses: actions/upload-artifact@6f51ac03b9356f520e9adb1b1b7802705f340c2b # v4.5.0
        with:
          name: docker-image-multiplatform
          path: /tmp/docker-image-multiplatform.tar
          retention-days: 1

      - name: Upload test image artifact
        uses: actions/upload-artifact@6f51ac03b9356f520e9adb1b1b7802705f340c2b # v4.5.0
        with:
          name: docker-image-test
          path: /tmp/docker-image-test.tar
          retention-days: 1

      # Verify build success
      - name: Verify build success
        run: |
          echo "Build completed successfully"
          echo "Image tag: ${{ steps.extract-tag.outputs.primary-tag }}"
          if [ ! -f "/tmp/docker-image-multiplatform.tar" ] || [ ! -f "/tmp/docker-image-test.tar" ]; then
            echo "ERROR: Build failed - image files not generated"
            ls -la /tmp/docker-image-*.tar 2>/dev/null || echo "No image files found"
            exit 1
          else
            echo "SUCCESS: Docker images built successfully"
            ls -lh /tmp/docker-image-*.tar
          fi

  docker-push:
    name: 'Push Docker Image'
    runs-on: ubuntu-latest
    needs: docker-build
    if: github.event_name != 'pull_request'
    timeout-minutes: 15
    outputs:
      image-digest: ${{ steps.push.outputs.digest }}

    steps:
      # Harden the runner used by this workflow
      - name: Harden Runner
        uses: step-security/harden-runner@0634a2670c59f64b4a01f0f96f84700a4088b9f0 # v2.12.0
        with:
          egress-policy: audit

      # Set up Docker Buildx
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@8026d2bc3645ea78b0d2544766a1225eb5691f89 # v3.8.0

      # Login to GitHub Container Registry
      - name: Log in to Container Registry
        uses: docker/login-action@9780b0c442fbb1117ed29e0efdff1e18412f7567 # v3.3.0
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # Download the built image
      - name: Download Docker image artifact
        uses: actions/download-artifact@fa0a91b85d4f404e444e00e005971372dc801d16 # v4.1.8
        with:
          name: docker-image-multiplatform
          path: /tmp

      # Push multi-platform image directly from OCI format
      - name: Push Docker image
        id: push
        uses: docker/build-push-action@48aba3b46d1b1fec4febb7c5d0c644b249a11355 # v6.10.0
        with:
          context: .
          file: ./Dockerfile
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ needs.docker-build.outputs.image-tags }}
          labels: ${{ needs.docker-build.outputs.image-labels }}
          # Reuse cache from build job
          cache-from: |
            type=gha

      # Generate attestation for the image
      - name: Generate artifact attestation
        uses: actions/attest-build-provenance@1c608d11d69870c2092266b3f9a6f3abbf17002c # v1.4.3
        with:
          subject-name: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          subject-digest: ${{ steps.push.outputs.digest }}
          push-to-registry: true

  # Test the built image
  docker-test:
    name: 'Test Docker Image'
    runs-on: ubuntu-latest
    needs: docker-build
    timeout-minutes: 15

    steps:
      # Harden the runner used by this workflow
      - name: Harden Runner
        uses: step-security/harden-runner@0634a2670c59f64b4a01f0f96f84700a4088b9f0 # v2.12.0
        with:
          egress-policy: audit

      # Checkout repository to access local actions
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@8026d2bc3645ea78b0d2544766a1225eb5691f89 # v3.8.0

      # Download the test image
      - name: Download test image artifact
        uses: actions/download-artifact@fa0a91b85d4f404e444e00e005971372dc801d16 # v4.1.8
        with:
          name: docker-image-test
          path: /tmp

      # Load the image into Docker
      - name: Load Docker image
        run: |
          docker load --input /tmp/docker-image-test.tar
          echo "Loaded images:"
          docker image ls

          # Extract the image tag that was actually loaded
          LOADED_TAG=$(docker image ls --format "table {{.Repository}}:{{.Tag}}" | grep -E "http-api-tool|ghcr.io" | head -n1)
          echo "LOADED_TAG=$LOADED_TAG" >> "$GITHUB_ENV"
          echo "Using loaded image tag: $LOADED_TAG"

      # Test the image with basic functionality
      - name: Test Docker image help
        run: |
          docker run --rm "$LOADED_TAG" --help

      - name: Setup go-httpbin HTTPS service
        uses: ./.github/actions/go-httpbin
        id: go-httpbin
        with:
          debug: 'true'

      - name: Test Docker image with go-httpbin
        run: |
          echo "Using loaded image tag: $LOADED_TAG"

          # Get service URL and CA bundle from go-httpbin action
          SERVICE_URL="${{ steps.go-httpbin.outputs.service-url }}"
          CA_BUNDLE="${{ steps.go-httpbin.outputs.ca-cert-path }}"

          # Test the http-api-tool against go-httpbin with HTTPS
          docker run --rm --network host \
            -v "$GITHUB_WORKSPACE/$CA_BUNDLE:/tmp/ca-bundle.pem:ro" \
            "$LOADED_TAG" \
            test \
            --url "$SERVICE_URL/get" \
            --ca-bundle-path "/tmp/ca-bundle.pem" \
            --debug \
            --retries 3

      - name: Clean up test containers
        if: always()
        run: |
          docker rm -f go-httpbin || true

  # Vulnerability scan
  docker-security-scan:
    name: 'Security Scan'
    runs-on: ubuntu-latest
    needs: [docker-build, docker-push]
    if: github.event_name != 'pull_request'
    timeout-minutes: 15
    permissions:
      contents: read
      security-events: write

    steps:
      # Harden the runner used by this workflow
      - name: Harden Runner
        uses: step-security/harden-runner@0634a2670c59f64b4a01f0f96f84700a4088b9f0 # v2.12.0
        with:
          egress-policy: audit

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@76071ef0d7ec797419534a183b498b4d6366cf37 # v0.31.0
        with:
          image-ref: ${{ needs.docker-build.outputs.image-tag }}
          format: 'sarif'
          output: 'trivy-results.sarif'

      - name: Upload Trivy scan results to GitHub Security tab
        uses: github/codeql-action/upload-sarif@ce28f5bb42b7a9f2c824e633a3f6ee835bab6858 # v3.29.0
        if: always()
        with:
          sarif_file: 'trivy-results.sarif'
