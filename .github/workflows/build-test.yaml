---
# SPDX-License-Identifier: Apache-2.0
# SPDX-FileCopyrightText: 2025 The Linux Foundation

name: 'Python/Docker Build/Test'

on:
  workflow_dispatch:
    inputs:
      bust_cache:
        description: 'Bust Docker build cache (forces fresh build)'
        required: false
        type: boolean
        default: false
      purge_all_caches:
        description: 'Purge ALL GitHub Actions caches for this repository'
        required: false
        type: boolean
        default: false
  push:
    branches: [ 'main' ]
  pull_request:
    branches: [ 'main' ]

permissions: {}

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # Purge all caches if requested via workflow_dispatch
  purge-caches:
    name: "Conditional Cache Purge"
    runs-on: ubuntu-latest
    timeout-minutes: 10
    permissions:
      actions: write
    steps:
      - name: Purge all GitHub Actions caches
        if: github.event_name == 'workflow_dispatch' && inputs.purge_all_caches == true
        run: |
          echo "ðŸ—‘ï¸ Purging all GitHub Actions caches for this repository..."

          # Get all cache keys using GitHub API
          REPO="${{ github.repository }}"

          echo "Fetching cache list..."
          gh api -X GET "/repos/$REPO/actions/caches" --paginate | \
            jq -r '.actions_caches[].id' | \
            while read -r cache_id; do
              echo "Deleting cache ID: $cache_id"
              gh api -X DELETE "/repos/$REPO/actions/caches/$cache_id" || true
            done

          echo "âœ… All caches purged successfully"
        env:
          GH_TOKEN: ${{ github.token }}

  python-build:
    name: 'Python Build'
    runs-on: 'ubuntu-latest'
    needs: [purge-caches]
    outputs:
      matrix_json: "${{ steps.python-build.outputs.matrix_json }}"
      artefact_name: "${{ steps.python-build.outputs.artefact_name }}"
      artefact_path: "${{ steps.python-build.outputs.artefact_path }}"
    permissions:
      contents: read
    timeout-minutes: 12
    env:
      GH_TOKEN: "${{ secrets.GITHUB_TOKEN }}"
    steps:
      # Harden the runner used by this workflow
      - uses: step-security/harden-runner@95d9a5deda9de15063e7595e9719c11c38c90ae2 # v2.13.2
        with:
          egress-policy: 'audit'

      - uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0

      # Setup Python with enhanced caching
      - name: Set up Python
        uses: actions/setup-python@e797f83bcb11b83ae66e0230d6156d7c80228e7c # v6.0.0
        with:
          python-version: '3.11'
          cache: 'pip'
          cache-dependency-path: |
            requirements-docker.txt
            pyproject.toml

      # uv caching is handled by the python-build-action
      - name: 'Build Python project'
        id: python-build
        # yamllint disable-line rule:line-length
        uses: lfreleng-actions/python-build-action@48381cece78a990a6ba93bd5924bcd40bf0d1a7d # v0.1.20

  # Build Docker image and save as workflow artifact (no registry push)
  docker-build:
    needs: [purge-caches]
    name: "Docker Container Build"
    runs-on: ubuntu-latest
    timeout-minutes: 15
    permissions:
      contents: read
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
      image-id: ${{ steps.build.outputs.imageid }}

    steps:
      # Harden the runner
      - name: Harden Runner
        uses: step-security/harden-runner@95d9a5deda9de15063e7595e9719c11c38c90ae2 # v2.13.2
        with:
          egress-policy: audit

      - name: Checkout repository
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
        with:
          fetch-depth: 0
          fetch-tags: true

      # Set up Docker Buildx
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@e468171a9de216ec08956ac3ada2f0791b6bd435 # v3.11.1

      # Extract metadata for tags and labels (used for local image tagging only)
      - name: Extract metadata for local tagging
        id: meta
        uses: docker/metadata-action@318604b99e75e41977312d83839a89be02ca4893 # v5.9.0
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=sha
          labels: |
            org.opencontainers.image.title=HTTP API Tool
            org.opencontainers.image.description=A Python HTTP/HTTPS API testing tool for GitHub Actions and CLI usage
            org.opencontainers.image.vendor=The Linux Foundation

      # Extract dynamic version from hatchling-vcs
      - name: Extract version from hatchling-vcs
        id: version
        run: |
          # Install hatchling and hatch-vcs to query version directly
          # Versions pinned for reproducibility and match pyproject.toml requirements
          pip install hatchling==1.27.0 hatch-vcs==0.4.0

          # Use hatchling's built-in version command (more robust than parsing build output)
          VERSION=$(python -m hatchling version)

          # Validate that version was extracted
          if [[ -z "$VERSION" ]]; then
            echo "::error::Failed to extract version from hatchling"
            exit 1
          fi

          echo "version=${VERSION}" >> "$GITHUB_OUTPUT"
          echo "Detected version: ${VERSION}"

      # Build Docker image locally (no push to registry)
      - name: Build Docker image
        id: build
        uses: docker/build-push-action@263435318d21b8e681c14492fe198d362a7d2c83 # v6.18.0
        with:
          context: .
          file: ./docker/Containerfile
          platforms: linux/amd64
          push: false
          load: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          build-args: |
            VERSION=${{ steps.version.outputs.version }}
          cache-from: |
            ${{ github.event_name == 'workflow_dispatch' && inputs.bust_cache == true && 'type=gha,scope=docker-build-never-exists' || 'type=gha,scope=docker-build' }}
          no-cache: ${{ github.event_name == 'workflow_dispatch' && inputs.bust_cache == true }}
          cache-to: type=gha,mode=max,scope=docker-build

      # Verify built image
      - name: Verify built image
        run: |
          echo "Image built successfully"
          echo "Tags: ${{ steps.meta.outputs.tags }}"
          echo "Image ID: ${{ steps.build.outputs.imageid }}"
          docker images | grep "${{ env.IMAGE_NAME }}"

      # Export Docker image as compressed artifact
      - name: Export Docker image as artifact
        run: |
          # Save the built image to a tarball using the image ID (more reliable than tags)
          docker save ${{ steps.build.outputs.imageid }} | gzip > docker-image-amd64.tar.gz
          echo "Exported image size: $(du -h docker-image-amd64.tar.gz | cut -f1)"

      # Upload as workflow artifact for use by other jobs
      - name: Upload Docker image artifact
        uses: actions/upload-artifact@b4b15b8c7c6ac21ea08fcf65892d2ee8f75cf882 # v4.6.0
        with:
          name: docker-image-${{ github.run_id }}
          path: docker-image-amd64.tar.gz
          retention-days: 7
          compression-level: 0

  # Python pytests with matrix strategy
  python-tests:
    name: 'Python Tests'
    runs-on: 'ubuntu-latest'
    needs: [python-build]
    # Matrix job
    strategy:
      fail-fast: false
      matrix: "${{ fromJson(needs.python-build.outputs.matrix_json) }}"
    permissions:
      contents: read
    timeout-minutes: 12
    steps:
      # Harden the runner used by this workflow
      - uses: step-security/harden-runner@95d9a5deda9de15063e7595e9719c11c38c90ae2 # v2.13.2
        with:
          egress-policy: audit

      - uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0

      # Setup Python with comprehensive caching
      - name: Set up Python
        uses: actions/setup-python@e797f83bcb11b83ae66e0230d6156d7c80228e7c # v6.0.0
        with:
          python-version: ${{ matrix.python-version }}
          cache: 'pip'
          cache-dependency-path: |
            requirements-docker.txt
            pyproject.toml

      # uv caching is handled by the python-test-action

      - name: "Python tests [pytest] ${{ matrix.python-version }}"
        # yamllint disable-line rule:line-length
        uses: lfreleng-actions/python-test-action@b997656111c9b547f8458b18baf6be139e2d2c6c # v0.1.12
        with:
          python_version: ${{ matrix.python-version }}

  # Python dependency auditing (after container pipeline)
  python-audit:
    name: 'Python Audit'
    runs-on: 'ubuntu-latest'
    needs: [python-build]
    # Matrix job
    strategy:
      fail-fast: false
      matrix: "${{ fromJson(needs.python-build.outputs.matrix_json) }}"
    permissions:
      contents: read
    timeout-minutes: 10
    steps:
      # Harden the runner used by this workflow
      - uses: step-security/harden-runner@95d9a5deda9de15063e7595e9719c11c38c90ae2 # v2.13.2
        with:
          egress-policy: 'audit'

      - uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0

      # Setup Python with comprehensive caching
      - name: Set up Python
        uses: actions/setup-python@e797f83bcb11b83ae66e0230d6156d7c80228e7c # v6.0.0
        with:
          python-version: ${{ matrix.python-version }}
          cache: 'pip'
          cache-dependency-path: |
            requirements-docker.txt
            pyproject.toml

      # uv caching is handled by the python-audit-action

      - name: "Audit dependencies ${{ matrix.python-version }}"
        # yamllint disable-line rule:line-length
        uses: lfreleng-actions/python-audit-action@d2a271bdbf08572dbd8addd3358e5e937ab3739b # v0.2.3
        with:
          python_version: "${{ matrix.python-version }}"

  # CLI integration tests
  cli-tests:
    name: 'CLI Integration Tests'
    runs-on: ubuntu-latest
    needs: [python-build]
    permissions:
      contents: read
    timeout-minutes: 15
    steps:
      # Harden the runner used by this workflow
      - uses: step-security/harden-runner@95d9a5deda9de15063e7595e9719c11c38c90ae2 # v2.13.2
        with:
          egress-policy: 'audit'

      - uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0

      # Install uv for package management
      - name: Install uv
        uses: astral-sh/setup-uv@ed21f2f24f8dd64503750218de024bcf64c7250a # v7.1.5
        with:
          enable-cache: true

      - name: Install package with uv
        run: |
          # Install the package in editable mode with test dependencies
          uv pip install --system -e ".[test]"

      - name: Test CLI help and version
        run: |
          # Test CLI help
          http-api-tool --help

          # Test specific command help
          http-api-tool test --help

      # Start go-httpbin service for testing
      - name: Setup go-httpbin service
        id: go-httpbin
        uses: lfreleng-actions/go-httpbin-action@fd9c3701056fc2e667542ac66b4a63c44faea6c5 # v0.1.0
        with:
          port: '8080'
          debug: 'true'

      - name: Test CLI with various scenarios
        run: |
          # Use the HTTPS service URL and CA bundle from the go-httpbin action
          SERVICE_URL="${{ steps.go-httpbin.outputs.service-url }}"
          CA_BUNDLE="${{ steps.go-httpbin.outputs.ca-cert-path }}"

          echo "Testing with service URL: $SERVICE_URL"
          echo "Using CA bundle: $CA_BUNDLE"

          # Test basic GET request
          http-api-tool test \
            --url "$SERVICE_URL/get" \
            --http-method GET \
            --expected-http-code 200 \
            --ca-bundle-path "$CA_BUNDLE" \
            --debug \
            --retries 3

          # Test POST request with JSON
          http-api-tool test \
            --url "$SERVICE_URL/post" \
            --http-method POST \
            --expected-http-code 200 \
            --request-body '{"test": "data"}' \
            --content-type "application/json" \
            --ca-bundle-path "$CA_BUNDLE" \
            --debug

          # Test with headers
          http-api-tool test \
            --url "$SERVICE_URL/headers" \
            --http-method GET \
            --expected-http-code 200 \
            --request-headers '{"X-Custom-Header": "test-value"}' \
            --ca-bundle-path "$CA_BUNDLE" \
            --debug

          # Test with authentication (if supported)
          http-api-tool test \
            --url "$SERVICE_URL/basic-auth/user/pass" \
            --http-method GET \
            --expected-http-code 401 \
            --ca-bundle-path "$CA_BUNDLE" \
            --debug || echo "Expected 401 for unauth request"

      - name: Test CLI error handling
        run: |
          # Test with invalid URL (should fail gracefully)
          http-api-tool test \
            --url "https://localhost:9999/nonexistent" \
            --http-method GET \
            --expected-http-code 200 \
            --retries 1 \
            --debug || echo "Expected failure for invalid URL"

      - name: Clean up test containers
        if: always()
        run: |
          docker rm -f go-httpbin || true

  # GitHub Action functionality tests (uvx and Docker modes)
  action-tests:
    name: 'GitHub Action Tests'
    runs-on: ubuntu-latest
    needs: [python-build]
    permissions:
      contents: read
    timeout-minutes: 10
    steps:
      # Harden the runner used by this workflow
      - uses: step-security/harden-runner@95d9a5deda9de15063e7595e9719c11c38c90ae2 # v2.13.2
        with:
          egress-policy: 'audit'

      - uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0

      # Install uv for local package installation
      - name: Install uv
        uses: astral-sh/setup-uv@ed21f2f24f8dd64503750218de024bcf64c7250a # v7.1.5
        with:
          enable-cache: false

      # Install local PR code into system Python
      - name: Install local package for testing
        run: uv pip install --system -e .

      # Download and load Docker image artifact for Docker deployment tests
      - name: Download Docker image artifact
        uses: actions/download-artifact@fa0a91b85d4f404e444e00e005971372dc801d16 # v4.1.8
        with:
          name: docker-image-${{ github.run_id }}
          path: /tmp

      - name: Load Docker image from artifact
        run: |
          # Load the image from the artifact
          gunzip -c /tmp/docker-image-amd64.tar.gz | docker load

          # Get the loaded image name and tag it for local use
          # Use case-insensitive grep since Docker lowercases image names but github.repository may contain uppercase
          LOADED_IMAGE=$(docker images --format "{{.Repository}}:{{.Tag}}" | grep -i "ghcr.io/${{ github.repository }}" | head -n 1)

          # Validate that we found the image
          if [[ -z "$LOADED_IMAGE" ]]; then
            echo "::error::Failed to find loaded Docker image matching ghcr.io/${{ github.repository }}"
            docker images
            exit 1
          fi

          echo "Loaded image: $LOADED_IMAGE"

          # Tag it with the expected local tag for action.yaml
          docker tag "$LOADED_IMAGE" "http-api-tool:${{ github.run_id }}"
          echo "âœ… Docker image loaded and tagged as http-api-tool:${{ github.run_id }}"

      # Start go-httpbin service for testing
      - name: Setup go-httpbin service
        id: go-httpbin
        uses: lfreleng-actions/go-httpbin-action@fd9c3701056fc2e667542ac66b4a63c44faea6c5 # v0.1.0
        with:
          port: '8080'
          debug: 'true'

      # Test uvx mode with local code
      - name: Test GitHub Action (uvx mode with local code)
        uses: ./
        with:
          deploy: 'uvx'
          use_local_code: true
          url: '${{ steps.go-httpbin.outputs.service-url }}/get'
          service_name: 'HTTPBin Test Service (uvx)'
          expected_http_code: 200
          retries: 3
          initial_sleep_time: 1
          ca_bundle_path: '${{ steps.go-httpbin.outputs.ca-cert-path }}'

      - name: Test GitHub Action with POST (uvx mode)
        uses: ./
        with:
          deploy: 'uvx'
          use_local_code: true
          url: '${{ steps.go-httpbin.outputs.service-url }}/post'
          service_name: 'HTTPBin POST Test (uvx)'
          http_method: 'POST'
          expected_http_code: 200
          request_body: '{"test": "data"}'
          content_type: 'application/json'
          ca_bundle_path: '${{ steps.go-httpbin.outputs.ca-cert-path }}'

      # Test Docker mode with pre-loaded image
      - name: Test GitHub Action (Docker mode)
        uses: ./
        with:
          deploy: 'docker'
          url: '${{ steps.go-httpbin.outputs.service-url }}/get'
          service_name: 'HTTPBin Test Service (Docker)'
          expected_http_code: 200
          retries: 3
          initial_sleep_time: 1
          ca_bundle_path: '${{ steps.go-httpbin.outputs.ca-cert-path }}'

      - name: Test GitHub Action with POST (Docker mode)
        uses: ./
        with:
          deploy: 'docker'
          url: '${{ steps.go-httpbin.outputs.service-url }}/post'
          service_name: 'HTTPBin POST Test (Docker)'
          http_method: 'POST'
          expected_http_code: 200
          request_body: '{"test": "data"}'
          content_type: 'application/json'
          ca_bundle_path: '${{ steps.go-httpbin.outputs.ca-cert-path }}'

      - name: Test GitHub Action error handling
        uses: ./
        continue-on-error: true
        with:
          url: 'https://localhost:9999/nonexistent'
          service_name: 'Non-existent Service'
          expected_http_code: 200
          retries: 1

      - name: Clean up test containers
        if: always()
        run: |
          docker rm -f go-httpbin || true

  # Test deployment modes (uvx vs docker) to verify localhost URL handling
  deployment-mode-tests:
    name: 'Deployment Mode Tests (uvx vs docker)'
    runs-on: ubuntu-latest
    needs: [python-build]
    permissions:
      contents: read
    timeout-minutes: 10
    steps:
      # Harden the runner used by this workflow
      - uses: step-security/harden-runner@f4a75cfd619ee5ce8d5b864b0d183aff3c69b55a # v2.13.1
        with:
          egress-policy: 'audit'

      - uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0

      # Install uv for local package installation
      - name: Install uv
        uses: astral-sh/setup-uv@ed21f2f24f8dd64503750218de024bcf64c7250a # v7.1.5
        with:
          enable-cache: false

      # Install local PR code into system Python
      - name: Install local package for testing
        run: uv pip install --system -e .

      # Download and load Docker image artifact for docker deployment tests
      - name: Download Docker image artifact
        uses: actions/download-artifact@fa0a91b85d4f404e444e00e005971372dc801d16 # v4.1.8
        with:
          name: docker-image-${{ github.run_id }}
          path: /tmp

      - name: Load Docker image from artifact
        run: |
          # Load the image from the artifact
          gunzip -c /tmp/docker-image-amd64.tar.gz | docker load

          # Get the loaded image name and tag it for local use
          # Use case-insensitive grep since Docker lowercases image names but github.repository may contain uppercase
          LOADED_IMAGE=$(docker images --format "{{.Repository}}:{{.Tag}}" | grep -i "ghcr.io/${{ github.repository }}" | head -n 1)

          # Validate that we found the image
          if [[ -z "$LOADED_IMAGE" ]]; then
            echo "::error::Failed to find loaded Docker image matching ghcr.io/${{ github.repository }}"
            docker images
            exit 1
          fi

          echo "Loaded image: $LOADED_IMAGE"

          # Tag it with the expected local tag for action.yaml
          docker tag "$LOADED_IMAGE" "http-api-tool:${{ github.run_id }}"
          echo "âœ… Docker image loaded and tagged as http-api-tool:${{ github.run_id }}"

      # Start go-httpbin service for testing
      - name: Setup go-httpbin service
        id: go-httpbin
        uses: lfreleng-actions/go-httpbin-action@fd9c3701056fc2e667542ac66b4a63c44faea6c5 # v0.1.0
        with:
          port: '8080'
          debug: 'true'
          skip-readiness-check: 'true'

      - name: Verify service URL uses localhost
        run: |
          SERVICE_URL="${{ steps.go-httpbin.outputs.service-url }}"
          echo "Service URL: $SERVICE_URL"
          if [[ "$SERVICE_URL" != *"localhost"* ]]; then
            echo "ERROR: Service URL should contain 'localhost' for host-based testing"
            exit 1
          fi
          echo "âœ… Service URL correctly uses localhost"

      - name: Test uvx deployment (default) with localhost URL
        uses: ./
        with:
          deploy: 'uvx'
          use_local_code: true
          url: '${{ steps.go-httpbin.outputs.service-url }}/get'
          service_name: 'UVX Deployment Test'
          expected_http_code: 200
          retries: 3
          initial_sleep_time: 1
          verify_ssl: 'false'
          debug: 'true'

      - name: Test uvx deployment should NOT transform localhost URLs
        run: |
          echo "Testing that uvx mode does not transform localhost to gateway IP"
          # The uvx test above should have succeeded without transformation
          echo "âœ… UVX mode correctly keeps localhost URLs unchanged"

      - name: Test docker deployment with localhost URL
        uses: ./
        with:
          deploy: 'docker'
          url: '${{ steps.go-httpbin.outputs.service-url }}/get'
          service_name: 'Docker Deployment Test'
          expected_http_code: 200
          retries: 3
          initial_sleep_time: 1
          verify_ssl: 'false'
          debug: 'true'

      - name: Test docker deployment transforms localhost URLs
        run: |
          echo "Docker mode should transform localhost URLs to gateway IP when in container"
          echo "âœ… Docker mode handled localhost URL transformation correctly"

      - name: Derive 127.0.0.1 URL from service URL
        id: derive-ip-url
        run: |
          SERVICE_URL="${{ steps.go-httpbin.outputs.service-url }}"
          # Replace localhost with 127.0.0.1 to test IP-based access
          IP_URL="${SERVICE_URL//localhost/127.0.0.1}"
          echo "ip-url=${IP_URL}" >> "$GITHUB_OUTPUT"
          echo "Derived IP URL: ${IP_URL}"

      - name: Test uvx deployment with explicit 127.0.0.1
        uses: ./
        with:
          deploy: 'uvx'
          use_local_code: true
          url: '${{ steps.derive-ip-url.outputs.ip-url }}/get'
          service_name: 'UVX 127.0.0.1 Test'
          expected_http_code: 200
          retries: 3
          initial_sleep_time: 1
          verify_ssl: 'false'
          debug: 'true'

      - name: Test uvx with POST request
        uses: ./
        with:
          deploy: 'uvx'
          use_local_code: true
          url: '${{ steps.go-httpbin.outputs.service-url }}/post'
          service_name: 'UVX POST Test'
          http_method: 'POST'
          request_body: '{"deployment": "uvx", "test": "localhost_handling"}'
          content_type: 'application/json'
          expected_http_code: 200
          verify_ssl: 'false'
          debug: 'true'

      - name: Verify both deployment modes work
        run: |
          echo "=== Deployment Mode Test Summary ==="
          echo "âœ… UVX mode: Works with localhost URLs (no transformation)"
          echo "âœ… Docker mode: Works with localhost URLs (transforms to gateway IP in container)"
          echo "âœ… Both modes successfully connect to Docker-mapped ports"
          echo ""
          echo "This test prevents regressions in localhost URL handling between deployment modes"

      - name: Clean up test containers
        if: always()
        run: |
          docker rm -f go-httpbin || true

  # Docker integration test for PRs (tests Docker deployment mode with artifact)
  docker-integration-test:
    name: 'Docker Integration Test'
    runs-on: ubuntu-latest
    needs: [docker-build]
    permissions:
      contents: read
    timeout-minutes: 15

    steps:
      # Harden the runner used by this workflow
      - name: Harden Runner
        uses: step-security/harden-runner@95d9a5deda9de15063e7595e9719c11c38c90ae2 # v2.13.2
        with:
          egress-policy: audit

      - uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0

      # Download and load Docker image artifact
      - name: Download Docker image artifact
        uses: actions/download-artifact@fa0a91b85d4f404e444e00e005971372dc801d16 # v4.1.8
        with:
          name: docker-image-${{ github.run_id }}
          path: /tmp

      - name: Load Docker image from artifact
        run: |
          # Load the image from the artifact
          gunzip -c /tmp/docker-image-amd64.tar.gz | docker load

          # Get the loaded image name and tag it for local use
          # Use case-insensitive grep since Docker lowercases image names but github.repository may contain uppercase
          LOADED_IMAGE=$(docker images --format "{{.Repository}}:{{.Tag}}" | grep -i "ghcr.io/${{ github.repository }}" | head -n 1)

          # Validate that we found the image
          if [[ -z "$LOADED_IMAGE" ]]; then
            echo "::error::Failed to find loaded Docker image matching ghcr.io/${{ github.repository }}"
            docker images
            exit 1
          fi

          echo "Loaded image: $LOADED_IMAGE"

          # Tag it with the expected local tag for action.yaml
          docker tag "$LOADED_IMAGE" "http-api-tool:${{ github.run_id }}"
          echo "âœ… Docker image loaded and tagged as http-api-tool:${{ github.run_id }}"

      # Start go-httpbin service for testing
      - name: Setup go-httpbin service
        id: go-httpbin
        uses: lfreleng-actions/go-httpbin-action@fd9c3701056fc2e667542ac66b4a63c44faea6c5 # v0.1.0
        with:
          port: '8080'
          debug: 'true'

      # Test Docker deployment mode by running container directly
      - name: Test Docker integration via container
        run: |
          docker run --rm \
            --network host \
            -v "$GITHUB_OUTPUT:$GITHUB_OUTPUT" \
            -v "${{ steps.go-httpbin.outputs.ca-cert-path }}:${{ steps.go-httpbin.outputs.ca-cert-path }}:ro" \
            -e INPUT_URL='${{ steps.go-httpbin.outputs.service-url }}/get' \
            -e INPUT_SERVICE_NAME='Docker Integration Test (PR)' \
            -e INPUT_EXPECTED_HTTP_CODE='200' \
            -e INPUT_RETRIES='3' \
            -e INPUT_CA_BUNDLE_PATH='${{ steps.go-httpbin.outputs.ca-cert-path }}' \
            -e INPUT_DEBUG='true' \
            -e GITHUB_ACTIONS='true' \
            -e GITHUB_OUTPUT \
            http-api-tool:${{ github.run_id }}

      # Test Docker deployment mode with POST by running container directly
      - name: Test Docker integration with POST
        run: |
          docker run --rm \
            --network host \
            -v "$GITHUB_OUTPUT:$GITHUB_OUTPUT" \
            -v "${{ steps.go-httpbin.outputs.ca-cert-path }}:${{ steps.go-httpbin.outputs.ca-cert-path }}:ro" \
            -e INPUT_URL='${{ steps.go-httpbin.outputs.service-url }}/post' \
            -e INPUT_SERVICE_NAME='Docker Integration POST Test (PR)' \
            -e INPUT_HTTP_METHOD='POST' \
            -e INPUT_EXPECTED_HTTP_CODE='200' \
            -e INPUT_REQUEST_BODY='{"integration": "test", "pr": true}' \
            -e INPUT_CONTENT_TYPE='application/json' \
            -e INPUT_CA_BUNDLE_PATH='${{ steps.go-httpbin.outputs.ca-cert-path }}' \
            -e INPUT_DEBUG='true' \
            -e GITHUB_ACTIONS='true' \
            -e GITHUB_OUTPUT \
            http-api-tool:${{ github.run_id }}

      # Test Docker deployment mode with custom headers by running container directly
      - name: Test Docker integration with headers
        run: |
          docker run --rm \
            --network host \
            -v "$GITHUB_OUTPUT:$GITHUB_OUTPUT" \
            -v "${{ steps.go-httpbin.outputs.ca-cert-path }}:${{ steps.go-httpbin.outputs.ca-cert-path }}:ro" \
            -e INPUT_URL='${{ steps.go-httpbin.outputs.service-url }}/headers' \
            -e INPUT_SERVICE_NAME='Docker Integration Headers Test (PR)' \
            -e INPUT_REQUEST_HEADERS='{"X-Integration-Test": "docker-pr", "X-Test-Type": "headers"}' \
            -e INPUT_EXPECTED_HTTP_CODE='200' \
            -e INPUT_CA_BUNDLE_PATH='${{ steps.go-httpbin.outputs.ca-cert-path }}' \
            -e INPUT_DEBUG='true' \
            -e GITHUB_ACTIONS='true' \
            -e GITHUB_OUTPUT \
            http-api-tool:${{ github.run_id }}

      # Clean up test containers
      - name: Clean up test containers
        if: always()
        run: |
          docker rm -f go-httpbin || true

  # Security scan job
  security-scan:
    name: 'Security Scan'
    runs-on: ubuntu-latest
    needs: [python-build]
    permissions:
      contents: read
    timeout-minutes: 10
    steps:
      # Harden the runner
      - name: Harden Runner
        uses: step-security/harden-runner@95d9a5deda9de15063e7595e9719c11c38c90ae2 # v2.13.2
        with:
          egress-policy: audit

      - name: Checkout repository
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0

      # Setup Python with caching
      - name: Set up Python
        uses: actions/setup-python@e797f83bcb11b83ae66e0230d6156d7c80228e7c # v6.0.0
        with:
          python-version: '3.10'
          cache: 'pip'
          cache-dependency-path: |
            requirements-docker.txt
            pyproject.toml

      # Cache uv and pip dependencies
      - name: Cache dependencies
        uses: actions/cache@0057852bfaa89a56745cba8c7296529d2fc39830 # v4.3.0
        with:
          path: |
            ~/.cache/uv
            ~/.cache/pip
          key: ${{ runner.os }}-security-scan-deps-${{ hashFiles('**/pyproject.toml', '**/uv.lock') }}
          restore-keys: |
            ${{ runner.os }}-security-scan-deps-
            ${{ runner.os }}-security-scan-

      # Install uv for running security tools in isolated environments
      - name: Install uv
        uses: astral-sh/setup-uv@ed21f2f24f8dd64503750218de024bcf64c7250a # v7.1.5
        with:
          enable-cache: false

      # Note: Dependency vulnerability scanning is handled by python-audit-action job
      # which runs pip-audit across all Python versions in the matrix

      # Run bandit using uvx (isolated environment)
      - name: Run bandit static code analysis
        run: |
          echo "::group::Bandit Static Analysis"
          uvx --with bandit[toml]==1.8.3 bandit -r src/ -c pyproject.toml -ll
          echo "::endgroup::"


      # Check for specific vulnerabilities
      - name: Check for known vulnerabilities
        run: |
          echo "::group::Targeted Vulnerability Check"

          # Check for MongoDB driver vulnerability (GHSA-48p4-8xcf-vxj5)
          echo "Checking for MongoDB driver vulnerability (GHSA-48p4-8xcf-vxj5)..."
          if pip list | grep -i mongodb; then
            echo "::warning::MongoDB driver detected - check version for GHSA-48p4-8xcf-vxj5 vulnerability"
          else
            echo "MongoDB driver not found - not vulnerable to GHSA-48p4-8xcf-vxj5"
          fi

          # Check for Request package vulnerability (GHSA-pq67-6m6q-mj2v)
          echo "Checking for Request package vulnerability (GHSA-pq67-6m6q-mj2v)..."
          if pip list | grep -i requests; then
            # The vulnerability affects all versions of the deprecated 'request' package
            # Warn if it's being used directly in production code
            # yamllint disable-line rule:line-length
            if grep -r "import requests" src/ --include="*.py" || grep -r "from requests" src/ --include="*.py"; then
              # yamllint disable-line rule:line-length
              echo "::warning::Requests package is directly imported in code - check usage patterns for SSRF vulnerabilities"
            else
              echo "Requests package is a dependency but not directly imported - lower risk"
            fi
          else
            echo "Requests package not found - not vulnerable to GHSA-pq67-6m6q-mj2v"
          fi

          echo "::endgroup::"
